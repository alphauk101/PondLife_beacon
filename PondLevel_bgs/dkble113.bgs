dim resCode
dim port
dim pinState
dim state

procedure switchLEDon()
	call hardware_io_port_write(1, $01,1)(resCode)
end
procedure switchLEDoff()
	call hardware_io_port_write(1, $01,0)(resCode)
end


#init gap mod, bonding and start freerunning times on system boot
event system_boot(major ,minor ,patch ,build ,ll_version ,protocol_version ,hw )
	#Set device to advertisement mode and allow undirected connections
	call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
	#Allow pairing
	call sm_set_bondable_mode(1)
	
	#set timer to periodically create an interrupt with interval of 1s
	call hardware_set_soft_timer($4000,0,0)
	
	#set the display to command mode
	call hardware_io_port_write(1,$7,$1)
	call hardware_io_port_config_direction(1,$7)
	#initialize the display
	call hardware_spi_transfer(0,11,"\x30\x30\x30\x39\x14\x56\x6d\x70\x0c\x06\x01")
	# Change display cursor pos
	call hardware_spi_transfer(0,1,"\x80")
	#set the display to data mode
	call hardware_io_port_write(1,$7,$3)
	#Write temperature to display
	call hardware_spi_transfer(0,16,"    DKBLE113    ")
	
	#set the display to command mode
	call hardware_io_port_write(1,$7,$1)
	# Change display cursor pos
	call hardware_spi_transfer(0,1,"\xc0")
	#set the display to data mode
	call hardware_io_port_write(1,$7,$3)
	#Write temperature to display
	call hardware_spi_transfer(0,16,"GO!!!!!!!!!!!!!!")
	
	call hardware_io_port_config_direction(1,$01)
	state = 0
	call switchLEDon()
	#Should config sets pin 1 to out and the rest to in.
	
end



#timer expired
event hardware_soft_timer(handle)
	#Request for ADC reading
	call hardware_io_port_read(1,$01)(resCode,port,pinState)
	if state = 0 then
	call switchLEDon()
	state = 1
	else
	call switchLEDoff()
	state = 0
	end if
	
	#call hardware_adc_read(14,3,0)
end



event connection_disconnected(handle,result)
	#in case if disconnect, return to advertisement mode
    call gap_set_mode(gap_general_discoverable,gap_undirected_connectable)
end
